# GIT

[learngitbranching](https://learngitbranching.js.org/)

## Основные команды git

| CMD          | DESCRIPTION    |
| ------------ | -------------- |
| `git init`   | инициализирует новый репозиторий git и начинает отслеживание существующего каталога. В существующий каталог добавляется скрытая вложенная папка, в которой размещается внутренняя структура данных, необходимая для управления версиями.|
| `git clone`  | создает локальную копию проекта, который уже существует удаленно. Клон включает в себя все файлы проекта, журнал и ветви.|
| `git add`    | подготавливает изменение. git отслеживает изменения в базе кода разработчика, но для включения изменений в журнал проекта необходимо подготавливать их и создавать моментальные снимки. Эта команда выполняет первую часть этого двухэтапного процесса, то есть подготовку. Все подготовленные изменения станут частью следующего моментального снимка и журнала проекта. Раздельные подготовка и фиксация дают разработчикам полный контроль над историей проекта без необходимости изменять подход к написанию кода и работе в целом. |
| `git commit` | сохраняет моментальный снимок в журнале проекта и завершает процесс отслеживания изменений. Иначе говоря, фиксация похожа на создание фотографии. Все, что было подготовлено с помощью команды git add, станет частью моментального снимка при использовании git commit.|
| `git status` | выводит состояние изменений: не отслеживаются, изменены или подготовлены.|
| `git branch` | показывает ветви, с которыми ведется локальная работа.|
| `git merge`  | выполняет слияние линий разработки. Эта команда обычно применяется для объединения изменений, внесенных в двух разных ветвях. Например, разработчик выполняет слияние, когда необходимо объединить изменения из ветви функции с главной ветвью для развертывания.|
| `git pull`   | применяет к локальной линии разработки обновления из удаленного аналога. Разработчики используют эту команду, если коллега выполнил фиксации в ветви удаленного репозитория и эти изменения нужно отразить в локальной среде.|
| `git push`   | обновляет удаленный репозиторий с учетом фиксаций, выполненных в ветви локально.|
| `git commit` | создание комита|


## https://learngitbranching.js.org/

## git comands

| CMD          | DESCRIPTION    |
| ------------ | -------------- |

`git log` отображает отправленные снимки состояния и позволяет просматривать и фильтровать историю проекта, а также искать в ней конкретные изменения

`git status` отображает состояние рабочего каталога и раздела проиндексированных файлов. С ее помощью можно проверить индексацию изменений и увидеть файлы, которые не отслеживаются git. Информация об истории коммитов проекта не отображается при выводе данных о состоянии.

`git commit` создание коммита

`git commit --amend` eсли изменения еще не были отправлены во внешнюю систему, можно добавить изменения в текущий коммит, для этого во время коммита добавляется флаг `--amend`

`git branch` создание ветки

`git branch -f [from name] [to name]` \
`git branch -f [from name] [to name]^^` перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции `-f` (force)

`git reset [name]^` отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; `git reset` перенесёт ветку назад, как будто некоторых коммитов вовсе и не было. `reset` отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.

`git revert [name]` отменяет изменения, перенося ссылку на ветку назад для удаленного коммита, на более старый коммит и поделиться отменёнными изменениями с остальными. После `revert` будет создан новый коммит `[name]'` который содержит изменения, полностью противоположные тем, что сделаны в коммите `[name]`. После `revert` можно сделать `push` и поделиться изменениями с остальными.


`git checkout [name]` выбор ветки

`git checkout -b [name]` создание ветки и переключение на нее

`git checkout [name]^` Перемещение на один коммит назад

`git checkout [name]~<num>` Перемещение на несколько коммитов назад

`git checkout [name]^^` \
`git checkout [name]~2` Перемещение на два коммита назад

`git checkout [name]^2` номер после `^` определяет, на какого из родителей мерджа надо перейти.

`git checkout HEAD~^2~2` модификаторы можно применять вместе

`HEAD` символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данный момент работаем. Отделение (detaching) `HEAD` означает лишь присвоение его не ветке, а конкретному коммиту

`git merge [name]` слияние или просто мердж. Слияния в git создают особый вид коммита, который имеет сразу двух родителей. Коммит с двумя родителями обычно означает, что мы хотим объединить изменения из одного коммита с другим коммитом и всеми их родительскими коммитами

`git rebase [name]` вид слияния. При `rebase` git копирует набор коммитов и переносит их в другое место. Благодаря этому всё будет выглядеть, как будто эти изменения делались последовательно, хотя на самом деле - параллельно.

`git rebase [name] -i` Если добавить интерактивную опцию `-i`, git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.

`git cherry-pick` \
`git cherry-pick <Commit1> <Commit2> <...>` прямолинейный способ указать место (в котором находится `HEAD`), куда нужно копировать несколько коммитов. `cherry-pick` поместит любой коммит сразу после `HEAD` (только если этот коммит не является предком `HEAD`)


`git tag [tag name] [name]` - Создание ссылки на конкретный коммит, если конкретный коммит не указан, git пометит тегом `HEAD`.

`git describe <ref>` показывает, как далеко текущее состояние от ближайшего тега, где `ref` — это что-либо, что указывает на конкретный коммит. Если не указать `ref`, то git будет считать, что указано текущее положение (`HEAD`). \
Вывод команды выглядит примерно так:
`<tag>_<numCommits>_g<hash>` где `tag` – это ближайший тег в истории изменений, `numCommits` – это на сколько далеко мы от этого тега, а `hash` – это хеш коммита, который описывается.


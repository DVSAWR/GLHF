# GIT

[learngitbranching](https://learngitbranching.js.org/)

## git comands

### git init

`git init` инициализирует новый репозиторий git и начинает отслеживание существующего каталога. В существующий каталог добавляется скрытая вложенная папка, в которой размещается внутренняя структура данных, необходимая для управления версиями.

### git add

`git add` подготавливает изменение. git отслеживает изменения в базе кода разработчика, но для включения изменений в журнал проекта необходимо подготавливать их и создавать моментальные снимки. Эта команда выполняет первую часть этого двухэтапного процесса, то есть подготовку. Все подготовленные изменения станут частью следующего моментального снимка и журнала проекта. Раздельные подготовка и фиксация дают разработчикам полный контроль над историей проекта без необходимости изменять подход к написанию кода и работе в целом.

### git commit

`git commit` создание коммита

`git commit --amend` eсли изменения еще не были отправлены во внешнюю систему, можно добавить изменения в текущий коммит, для этого во время коммита добавляется флаг `--amend`

### git branch

`git branch` создание ветки

`git branch -f [from name] [to name]` \
`git branch -f [from name] [to name]^^` перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции `-f` (force)

`git branch -u o/main [branchname]` создание связи для отслеживания `o/main`, и если вы так сделаете, эта ветка будет иметь такой же пункт назначения для `push` и `merge` как и локальная ветка `main`. Это значит, что вы можете выполнить `git push`, находясь на ветке `totallyNotMain`, и все ваши наработки с ветки `totallyNotMain` будут закачены на ветку `main` удалённого репозитория. Вы укажете ветке `[branchname]` следить за `o/main`. А если вы ещё при этом находитесь на ветке `[branchname]`, то её можно не указывать `git branch -u o/main`

### git resert

`git reset [name]^` отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; `git reset` перенесёт ветку назад, как будто некоторых коммитов вовсе и не было. `reset` отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.

### git revert

`git revert [name]` отменяет изменения, перенося ссылку на ветку назад для удаленного коммита, на более старый коммит и поделиться отменёнными изменениями с остальными. После `revert` будет создан новый коммит `[name]'` который содержит изменения, полностью противоположные тем, что сделаны в коммите `[name]`. После `revert` можно сделать `push` и поделиться изменениями с остальными.

### HEAD

`HEAD` символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данный момент работаем. Отделение (detaching) `HEAD` означает лишь присвоение его не ветке, а конкретному коммиту

### git checkout

`git checkout [name]` выбор ветки

`git checkout -b [name]` создание ветки и переключение на нее

`git checkout [name]^` Перемещение на один коммит назад

`git checkout [name]~<num>` Перемещение на несколько коммитов назад

`git checkout [name]^^` \
`git checkout [name]~2` Перемещение на два коммита назад

`git checkout [name]^2` номер после `^` определяет, на какого из родителей мерджа надо перейти.

`git checkout HEAD~^2~2` модификаторы можно применять вместе

`git checkout -b [name] o/main` создание связи для отслеживания `o/main`, и если вы так сделаете, эта ветка будет иметь такой же пункт назначения для `push` и `merge` как и локальная ветка `main`. Это значит, что вы можете выполнить `git push`, находясь на ветке `totallyNotMain`, и все ваши наработки с ветки `totallyNotMain` будут закачены на ветку `main` удалённого репозитория

### git merge

`git merge [name]` слияние или просто мердж. Слияния в git создают особый вид коммита, который имеет сразу двух родителей. Коммит с двумя родителями обычно означает, что мы хотим объединить изменения из одного коммита с другим коммитом и всеми их родительскими коммитами

### git rebase

`git rebase [name]` \
`git reabse [toname] [thisname]` вид слияния. При `rebase` git копирует набор коммитов и переносит их в другое место. Благодаря этому всё будет выглядеть, как будто эти изменения делались последовательно, хотя на самом деле - параллельно.

`git rebase [name] -i` Если добавить интерактивную опцию `-i`, git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.

### git chery-pick

`git cherry-pick` \
`git cherry-pick <commit1> <commit2> <...>` прямолинейный способ указать место (в котором находится `HEAD`), куда нужно копировать несколько коммитов. `cherry-pick` поместит любой коммит сразу после `HEAD` (только если этот коммит не является предком `HEAD`)

### git tag

`git tag [tag name] [name]` - Создание ссылки на конкретный коммит, если конкретный коммит не указан, git пометит тегом `HEAD`.

### git describe

`git describe <ref>` показывает, как далеко текущее состояние от ближайшего тега, где `ref` — это что-либо, что указывает на конкретный коммит. Если не указать `ref`, то git будет считать, что указано текущее положение (`HEAD`). \
Вывод команды выглядит примерно так:
`<tag>_<numCommits>_g<hash>` где `tag` – это ближайший тег в истории изменений, `numCommits` – это на сколько далеко мы от этого тега, а `hash` – это хеш коммита, который описывается.

### git log

`git log` отображает отправленные снимки состояния и позволяет просматривать и фильтровать историю проекта, а также искать в ней конкретные изменения

### git status

`git status` отображает состояние рабочего каталога и раздела проиндексированных файлов. С ее помощью можно проверить индексацию изменений и увидеть файлы, которые не отслеживаются git. Информация об истории коммитов проекта не отображается при выводе данных о состоянии.

### git clone

`git clone` создает локальную копию проекта, который уже существует удаленно. Клон включает в себя все файлы проекта, журнал и ветви.

### git fetch

`git fetch` процедура скачивания. связывается с указанным удалённым репозиторием и забирает все те данные проекта, которых у вас ещё нет, при этом у вас должны появиться ссылки на все ветки из этого удалённого репозитория Синхронизирует локальное представление удалённых репозиториев с тем, что является актуальным на текущий момент времени. `git fetch` забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент

### git pull

`git pull` применяет к локальной линии разработки обновления из удаленного аналога. Разработчики используют эту команду, если коллега выполнил фиксации в ветви удаленного репозитория и эти изменения нужно отразить в локальной среде. Объединяет в себе методы `fetch` и `merge`

`git pull --rebase` аналог для совместно вызванных `fetch` `merge` и `rebase`

`git pull origin foo` это то же самое, что сделать:
`git fetch origin foo; git merge o/foo`

`git pull origin bar:bugFix` то же, что:
`git fetch origin bar:bugFix; git merge bugFix`

### git push

`git push` отвечает за загрузку ваших изменений в указанный удалённый репозиторий, а также включение ваших коммитов в состав удалённого репозитория. Поведение команды `git push` без аргументов варьируется в зависимости от значения `push.default`, указанной в настройках git-а. Значение по умолчанию зависит от версии git, которую вы используете

`git push <удалённый_репозиторий> <целевая_ветка>` Указывая `main` в качестве аргумента `<целевая_ветка>`, мы тем самым говорим git откуда будут приходить и уходить наши коммиты. Аргумент `<целевая_ветка>` или "местонахождение" - это синхронизация между двумя репозиториями.

`git push origin <источник>:<получатель>` выборочная загрузка в удаленный репозиторий, в случае отсутствия ветки в удаленном репозитории он будет создана `git push origin main:newbranch`

### git fakeTeamwork

`git fakeTeamwork [branchname] <num>`- инициализация псевдо коммита на удаленном сервере (будто этот коммит был сделан другим человеком)
